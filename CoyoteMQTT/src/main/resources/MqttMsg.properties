#
# The formatting of these messages should conform to the rules for the 
# java.text.MessageFormat class
#

00101=<init> ClientID:{0} ServerURI:{1} PersistenceType:{2}
00105=< exception
00118=<200=internalSend key={0} message={1} token={2}
00204=connect failed: rc={0}
00207=connect failed: not disconnected {0}
00208=failed: not connected
00209=connect failed: unexpected exception
00210=failed: called on callback thread
00211=failed: already disconnected
00212=connect failed: unexpected exception
00213=fail: token in use: key={0} message={1} token={2}
00214=state=CONNECTING
00215=state=CONNECTED
00216=state=DISCONNECTING
00217=state=DISCONNECTED
00218=state=DISCONNECTING
00219=failed: already disconnecting
00223=failed: in closed state
00224=failed: not disconnected
00250=Failed to create TCP socket
00252=connect to host:{0} port:{1} timeout:{2}sec
00260=setEnabledCiphers ciphers={0}
00400=>key={0} timeout={1} sent={2} completed={3} hasException={4} response={5} token={6}
00401=failed with exception
00402=key={0} response={1}
00403=key={0}
00404=key={0} response={1} excep={2}
00406=key={0} timed out token={1}
00407=key={0} wait max={1} token={2}
00408=key={0} wait max={1}
00409=wait key={0}
00410=key={0}
00411=>key={0} response={1} excep={2}
00507=Client Connected, Offline Buffer available, but not empty. Adding message to buffer. message={0}
00508=Client Resting, Offline Buffer available. Adding message to buffer. message={0}
00509=Client Reconnected, Offline Buffer Available. Sending Buffered Messages.
00510=Publising Buffered message message={0}
00511=outbound QoS 0 publish key={0} message={1}
00514=Failed to persist buffered message key={0}
00516=Restoring all buffered messages
00609=removing orphaned pubrel key={0}
00659=start timer for client:{0}
00660=Check schedule at {0}
00661=stop
00717=call onFailure key {0}
00719=callback threw ex:
00852=network read message

callback.connection_lost_callback_exception=Processing exception during connectionLost callback - {0}
callback.connection_lost_cause=callback connection lost cause:{0}
callback.handle_action_completed=Callback and notify action completed for key:{0}
callback.handle_message=Calling messageArrived key:{0} topic:{1}
callback.message_arrived_notify=New message has arrived, notifying all of workAvailable
callback.on_failure=Callback call onFailure for token key:{0}
callback.on_success=Callback call onSuccess for token key:{0}
callback.operation_complete=Callback: operation complete - new work available. key:{0}
callback.quiesce=Quiesce notify spaceAvailable
callback.run_exception=Callback run threw exception, shutting the connection down - exception:{0}
callback.run_notify_spaceavailable=Callback run calling notify spaceAvailable
callback.stop=Stopping the callback thread - called by:{0}
callback.stop_complete=Callback stop complete
callback.stop_notify=Callback stop notify workAvailable and wait for run
callback.work_wait=Wait for workAvailable
callback.message_arrived_waitfor_space=Waiting for space in the inbound queue. queue size is {0} limit is {1}

client.attempt_reconnect=Automatically reconnecting client: {0}
client.attempt_reconnect_exception=Automatic reconnection threw exception: {0}
client.attempt_reconnect_failure=Automatic reconnect failed, rescheduling: {0}
client.attempt_reconnect_security_exception=Automatic reconnection threw security exception: {0}
client.attempt_reconnect_success=Automatic reconnect successful: {0}
client.cleaning_session=Client cleanSession:{0} connectionTimeout:{1} TimekeepAlive:{2} userName:{3} password:{4} will:{5} context:{6} callback:{7}
client.connect_failed=Client connect failed, state:{0}
client.connecting=Client connecting
client.created_network_transport=Using a network transport of {0}
client.creating_network_transports=Creating network transport for server at {0}
client.determining_network_transport=Determining which transport supports URI {0}
client.disconnect=Client disconnect called, quiesceTimeout:{0} context:{1} callback:{2}
client.disconnect_call_complete=Client disconnect call returning token: {0}
client.disconnect_call_failed=Client disconnect call failed, reason: {0}
client.disconnected=Client is disconnected.
client.disconnecting=Disconnecting client...
client.init=Client initialization - ClientID:{0} ServerURI:{1} PersistenceType:{2}
client.network_transports_created=Completed creating {0} network transports
client.publish=Publishing message on topic:{0} - message:{1} context:{1} callback:{2}
client.publish_complete=Published message, returning token:{0}
client.reconnect=Attempting to reconnect client:{0}
client.reconnect_reschedule=Rescheduling reconnect timer for client: {0}, delay: {1}
client.restoring_all_cached_messages=Restoring all cached messages
client.running_reconnect=Triggering Automatic Reconnect attempt.
client.start_reconnect=Start reconnect timer for client:{0}, delay:{1}
client.stop_reconnect=Stop reconnect timer for client:{0}
client.subscribe=Subscribe topicFilter:{0} context:{1} callback:{2}
client.subscribe_completed=Subscribe completed normally, token:{0}
client.unsubscribe=Unsubscribe topic:{0} context:{1} callback:{2}
client.unsubscribe_complete=Completed unsubscribe - token:{0}

clientstate.check_for_activity=checkForActivity entered
clientstate.check_for_activity_no_write=Timed out as no write activity, keepAlive:{0} lastOutboundActivity:{1} lastInboundActivity:{2} time:{3} lastPing:{4}
clientstate.check_for_activity_ping_needed=ping needed. keepAlive:{0} lastOutboundActivity:{1} lastInboundActivity:{2}
clientstate.check_for_activity_ping_not_needed=ping not needed yet. Schedule next ping
clientstate.check_for_activity_ping_scheduling=Schedule next ping at {0}
clientstate.check_for_activity_timed_out=Timed out as no activity, keepAlive:{0} lastOutboundActivity:{1} lastInboundActivity:{2} time:{3} lastPing:{4}
clientstate.check_quiesce_lock=quiescing:{0} actualInFlight:{1} pendingFlows:{2} inFlightPubRels:{3} callbackQuiesce:{4} tokens:{5}
clientstate.clearstate=clearState
clientstate.connected=connected
clientstate.decrement_inflight=decrementing in-flight messages actualInFlight:{0}
clientstate.delivery_complete=delivery complete, removed publish from persistence. key:{0}
clientstate.dequeuing_message=Dequing message key:{0} QoS:{1}
clientstate.disconnected=Setting client state to disconnected reason:{0}
clientstate.error_ack=Broker replied with error: {0}
clientstate.get_actual_inflight_count=+1 actualInFlight:{0}
clientstate.get_actual_inflight_full=inflight window full
clientstate.get_inflight_pubrel_count=+1 inflightpubrels:{0}
clientstate.get_no_flows_or_connect=no outstanding flows or not connected
clientstate.get_wait_end=new work or ping arrived 
clientstate.get_wait_start=wait for new work or for space in the inflight window
clientstate.notify_complete=notify complete, received key:{0} token:{1} message:{2}
clientstate.notify_complete_removed_qos1=removed Qos 1 publish. key:{0}
clientstate.notify_complete_removed_qos2=removed QoS 2 publish/pubrel. key:{0}, -1 inFlightPubRels:{1}
clientstate.notify_queue_lock_holders=notifying queueLock holders
clientstate.notify_result=Notifying tokens of result - key{0}, msg:{1}, excep:{2}
clientstate.notify_result_noack=Notifying tokens of no-ack result - key:{0},excep:{1}
clientstate.notify_sent=Client state notify sent key:{0}
clientstate.notify_sent_ping=ping sent. pingOutstanding: {0}
clientstate.notigy_received_message=Message receive notification key:{0} message:{1}
clientstate.persist_buffered_message=Persisted buffered message; key:{0}
clientstate.persist_buffered_message_fail=Could not persist ({0}), attempting to re-open persistence store
clientstate.persist_buffered_message_failure=Could not persist message; key:{0}, reason: {1}
clientstate.quiesce=Quiesce wait for outstanding: actualInFlight:{0} pendingFlows:{1} inFlightPubRels:{2} tokens:{3}
clientstate.quiesce_timeout=Quiesce timeout:{0}
clientstate.quiesced=Quiesce completed
clientstate.received_ack=Received an ACK key:{0} message:{1}
clientstate.received_ack_no_message=no message found for ack id:{0}
clientstate.received_ack_ping=ping response received. pingOutstanding: {0}
clientstate.received_bytes=Received bytes count:{0}
clientstate.resolve_old_tokens=Clientstate resolving old tokens, reason:{0}
clientstate.restore_inflight_message_publish=Restoring inflight message QoS 2 publish key:{0}
clientstate.restore_inflight_message_publish_qos0=Restoring inflight QoS 0 message key:{0}
clientstate.restore_inflight_message_publish_qos1=Restoring inflight QoS 1 message key:{0}
clientstate.restore_inflight_message_pubrel=Restoring inflight message QoS 2 pubrel key:{0}
clientstate.restore_state=Restoring client state
clientstate.restore_state_inbound_message=inbound QoS 2 publish key:{0} message:{1}
clientstate.restore_state_outbound_qos0_pub=outbound QoS 0 publish key:{0} message:{1}
clientstate.restore_state_outbound_qos1_pub=outbound QoS 1 publish key:{0} message:{1}
clientstate.restore_state_outbound_qos2_done=outbound QoS 2 completed key:{0} message:{1}
clientstate.restore_state_outbound_qos2_pub=outbound QoS 2 publish key:{0} message:{1}
clientstate.restore_state_outbound_qos2_pubrel=outbound QoS 2 pubrel key:{0} message:{1}
clientstate.restored_message=Restored message key:{0} message:{1}
clientstate.restored_message_failed=Restoring of message failed, key:{0} exception {1}
clientstate.send_max_inflight= sending {0} msgs at max inflight window
clientstate.send_pending=pending send key:{0} message {1}
clientstate.send_pending_publish=pending publish key:{0} qos:{1} message:{2}
clientstate.sent_bytes_count=Sent bytes count:{0}
clientstate.uncache_message=Removing message {0} from cache

connection.connect_failed=Connection failed - return code:{0}
connection.connect_failed=Connection failed for client {0} - {1}
connection.connected=Connection complete, client is connected to broker
connection.disconnect=Running background disconnect thread
connection.disconnect_failed_already_disconnected=Connection disconnect failed: already disconnected
connection.disconnect_failed_already_disconnecting=Connection disconnect failed: in the process of disconnecting
connection.disconnect_failed_in_callback_thread=Connection disconnect failed: DISCONNECT CALLED FROM CALLBACK THREAD
connection.disconnect_failed_in_closed_state=Connection disconnect failed: currently in closed state
connection.failed_send_nowait=Connection could not send NoWait - Not Connected message:{0}
connection.reconnect=Client notified as reconnected, publishing any cached messages
connection.reconnect_failed=Client reconnect failed: still not connected. Throwing exception.
connection.resting_send_nowait=Connection resting, storing NoWait message:{0}
connection.running=Client {0} connection is running
connection.send=Connection send key:{0} message:{1} token:{1}
connection.sending_cached_message=Sending cached message key:{0}
connection.storing_send_nowait=Connection storing NoWait message:{0}
connection.close_failed=Connection close called while still connected - close failed.

debug.logClientState=Client State debug information:{0}
debug.logConnOptions=Connection Options debug information:{0}
debug.logConnection=Connection debug information:{0}
debug.logSystemProperties=System Properties:{0}
debug.logVersion=API Version:{0}

messageinput.read_header=<<<<Read from network type:{0} length:{1}
messageinput.read_message=Message read from network:{0}
messageoutput.wrote_message=>>>>Wrote message to network:{0}

pingtimer.start=Ping timer started for client {0}
pingtimer.stopped=Ping timer stopped
pingtimer.run=Ping timer running activity check at {0}

receiver.run=Running receiver
receiver.run_return=Receiver running
receiver.run_stop=Receiver run stopping, MQttException: {0}
receiver.run_stop_io=Receiver run stopping due to IOException
receiver.start=Receiver starting
receiver.stop=Receiver stop called by {0}
receiver.stopped=Receiver stop complete
receiver.websocket_run=Running WebSocket receiver
receiver.websocket_start=WebSocket receiver starting
receiver.websocket_stop=WebSocket receiver stop called by {0}
receiver.websocket_stopped=WebSocket receiver stop complete

sender.sending=Sending message across network key:{0} msg:{1}
sender.sending_complete=Sender run complete
sender.sending_null=Sender receive null message (get message returned null), stopping
sender.stopped=Sender stopped
sender.stopping=Stopping sender - called by {0}
sender.handling_exception=Sender handling {0} exception

ssl.create_factory=SSL init: configID:{0}, application-enabled cipher suites:{1}
ssl.get_context_init=SSL init: configID:{0}, protocol:{1}
ssl.get_context_keystore_algo=SSL init: configID:{0}, keystore manager algorithm:{1}
ssl.get_context_keystore_name=SSL init: configID:{0}, keystore:{1}
ssl.get_context_keystore_password=SSL init: configID:{0}, keystore password:{1}
ssl.get_context_keystore_provider=SSL init: configID:{0}, keystore manager provider:{1}
ssl.get_context_keystore_type=SSL init: configID:{0}, keystore type:{1}
ssl.get_context_load=SSL init: loaded provider: configID:{0}, provider name:{1}
ssl.get_context_truststore_algo=SSL init: configID:{0}, truststore manager algorithm:{1}
ssl.get_context_truststore_name=SSL init: configID:{0}, truststore:{1}
ssl.get_context_truststore_password=SSL init: configID:{0}, truststore password:{1}
ssl.get_context_truststore_provider=SSL init: configID:{0}, truststore manager provider:{1}	
ssl.get_context_truststore_type=SSL init: configID:{0}, truststore type:{1}

tcptransport.connecting=Connecting to {0} port:{1} via TCP - timeout:{2}sec
tcptransport.failed_to_create_tcp_socket=TCP connection failed: {0}

token.mark_complete=Token marked complete key:{0} msg:{1} exception:{2}
token.notify_complete=Notifing token is complete key:{0}, response:{1}, exception:{2}
token.notify_sent=Notifying token is sent key:{0}
token.token_reset=Resetting token  key:{0}
token.wait_for_completion=Waiting {1}ms for token to complete for key:{0} ({2}) 
token.wait_for_completion_timeout=Timed out waiting for token to complete key:{0} ({1})
token.wait_for_response=Waiting for response key:{0}, timeout:{1}, sent:{2}, completed:{3}, excptn:{4}, response:{5}, token:{6}, {7}  
token.wait_for_response_done=Done waiting for a response key:{0}, response:{1}
token.wait_for_response_failed=Waiting for response failed key:{0}, exception:{1}
token.wait_for_response_start=Wait starting key:{0}, timeout:{1}
token.wait_until_sent=Token waiting until sent key:{0}

tokenstore.cleared=Clearing token store of {0} tokens
tokenstore.get_outstanding_delivery_tokens=Retrieving outstanding delivery tokens
tokenstore.get_outstanding_delivery_tokens_result=Found {0} outstanding delivery tokens
tokenstore.get_outstanding_tokens=Getting outstanding tokens
tokenstore.get_outstanding_tokens_result=Found {0} outstanding tokens
tokenstore.quiesce=tokenstore quiesce resp:{0}
tokenstore.remove_token=Removing token from token store key:{0}
tokenstore.restore_existing=Tokenstore returning existing token, key:{0} message:{1} token:{2}
tokenstore.restore_new=Tokenstore creating new token to return, key:{0} message:{1} token:{2}
tokenstore.saving_outbound_token=Saving outbound token key:{0} message:{1}
tokenstore.saving_token=Saving token key:"{0}" token:{1}
